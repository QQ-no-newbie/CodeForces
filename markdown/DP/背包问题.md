<!-- TOC -->

- [1. 背包问题](#1-背包问题)
  - [1.1. 01背包](#11-01背包)
    - [1.1.1. 模型](#111-模型)
    - [1.1.2. 思路](#112-思路)
    - [1.1.3. 模板](#113-模板)
  - [1.2. 完全背包](#12-完全背包)
    - [1.2.1. 模型](#121-模型)
    - [1.2.2. 思路](#122-思路)
    - [1.2.3. 模板](#123-模板)
  - [1.3. 多重背包](#13-多重背包)
    - [1.3.1. 模型](#131-模型)
    - [1.3.2. 思路](#132-思路)
    - [1.3.3. 模板](#133-模板)
  - [1.4. 分组背包](#14-分组背包)
    - [1.4.1. 模型](#141-模型)
    - [1.4.2. 思路](#142-思路)
    - [1.4.3. 模板](#143-模板)
  - [1.5. 二维费用背包](#15-二维费用背包)
    - [1.5.1. 模型](#151-模型)
    - [1.5.2. 思路](#152-思路)
    - [1.5.3. 模板](#153-模板)
  - [1.6. 混合背包](#16-混合背包)
    - [1.6.1. 模型](#161-模型)
    - [1.6.2. 思路](#162-思路)
    - [1.6.3. 模板](#163-模板)

<!-- /TOC -->
# 1. 背包问题

## 1.1. 01背包

### 1.1.1. 模型
 
有 N 件物品和一个容量是 V 的背包。

**每件物品只能使用一次。**

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

### 1.1.2. 思路

(1) 如果不装第 i 件物品，那么问题就转化为“前 i−1 件物品放入容量为 j 的背包中的最大价值”

(2) 如果装第 i 件物品，那么问题就转化为“前 i−1 件物品放入剩下的容量为 j−v[i] 的背包中的最大价值”

### 1.1.3. 模板
```cpp
void solve() {
  cin >> m >> n;
  vll a(n + 1), w(n + 1), dp(m + 1);
  for (int i = 1; i <= n; i++) cin >> a[i] >> w[i];
  for (int i = 1; i <= n; i++)
    for (int j = m; j >= a[i]; j--) {
      dp[j] = max(dp[j - a[i]] + w[i], dp[j]);
    }
  cout << dp[m] << endl;
  return;
}
```

## 1.2. 完全背包

### 1.2.1. 模型

有 N 件物品和一个容量是 V 的背包。

**每件物品使用无限次。**

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

### 1.2.2. 思路

### 1.2.3. 模板

## 1.3. 多重背包

### 1.3.1. 模型

有 N 件物品和一个容量是 V 的背包。

**每件物品有限使用次数。**

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

### 1.3.2. 思路

### 1.3.3. 模板

## 1.4. 分组背包

### 1.4.1. 模型

有 N 组物品和一个容量是 V 的背包。

**每组物品有若干个，同一组内的物品最多只能选一个。**

每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

### 1.4.2. 思路

### 1.4.3. 模板

## 1.5. 二维费用背包

### 1.5.1. 模型

有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。

**每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。**

求解将哪些物品装入背包，**可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量**，且价值总和最大。

### 1.5.2. 思路

### 1.5.3. 模板

## 1.6. 混合背包

### 1.6.1. 模型

### 1.6.2. 思路

### 1.6.3. 模板

